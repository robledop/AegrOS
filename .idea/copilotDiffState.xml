<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/kernel/task/process.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/kernel/task/process.c" />
              <option name="originalContent" value="#include &lt;assert.h&gt;&#10;#include &lt;debug.h&gt;&#10;#include &lt;elf.h&gt;&#10;#include &lt;idt.h&gt;&#10;#include &lt;kernel.h&gt;&#10;#include &lt;kernel_heap.h&gt;&#10;#include &lt;memory.h&gt;&#10;#include &lt;paging.h&gt;&#10;#include &lt;process.h&gt;&#10;#include &lt;rand.h&gt;&#10;#include &lt;serial.h&gt;&#10;#include &lt;spinlock.h&gt;&#10;#include &lt;status.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;thread.h&gt;&#10;#include &lt;vfs.h&gt;&#10;&#10;extern struct process_list process_list;&#10;&#10;struct process *current_process(void)&#10;{&#10;    pushcli();&#10;    const struct thread *current_task = get_current_thread();&#10;    if (current_task) {&#10;        popcli();&#10;        return current_task-&gt;process;&#10;    }&#10;&#10;    popcli();&#10;    return nullptr;&#10;}&#10;&#10;static int process_find_free_allocation_slot(const struct process *process)&#10;{&#10;    for (int i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (process-&gt;allocations[i].ptr == NULL) {&#10;            return i;&#10;        }&#10;    }&#10;&#10;    panic(&quot;Failed to find free allocation slot&quot;);&#10;    return -ENOMEM;&#10;}&#10;&#10;static struct process_allocation *process_get_allocation_by_address(struct process *process, const void *address)&#10;{&#10;    for (int i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (process-&gt;allocations[i].ptr == address) {&#10;            return &amp;process-&gt;allocations[i];&#10;        }&#10;    }&#10;&#10;    return nullptr;&#10;}&#10;&#10;int process_free_allocations(struct process *process)&#10;{&#10;    for (int i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (process-&gt;allocations[i].ptr == nullptr) {&#10;            continue;&#10;        }&#10;        process_free(process, process-&gt;allocations[i].ptr);&#10;    }&#10;&#10;    return 0;&#10;}&#10;&#10;int process_free_program_data(const struct process *process)&#10;{&#10;    int res = 0;&#10;    switch (process-&gt;file_type) {&#10;    case PROCESS_FILE_TYPE_BINARY:&#10;        if (process-&gt;pointer) {&#10;            kfree(process-&gt;pointer);&#10;        }&#10;        break;&#10;&#10;    case PROCESS_FILE_TYPE_ELF:&#10;        if (process-&gt;elf_file) {&#10;            elf_close(process-&gt;elf_file);&#10;        }&#10;        break;&#10;&#10;    default:&#10;        ASSERT(false, &quot;Unknown process file type&quot;);&#10;        res = -EINVARG;&#10;    }&#10;    return res;&#10;}&#10;&#10;void process_free_file_descriptors(struct process *process)&#10;{&#10;    for (int i = 0; i &lt; MAX_FILE_DESCRIPTORS; i++) {&#10;        if (process-&gt;file_descriptors[i]) {&#10;            vfs_close(process, i);&#10;        }&#10;    }&#10;}&#10;&#10;/// @brief Turn the process into a zombie and deallocates its resources&#10;/// The process remains in the process list until the parent process reads the exit code&#10;int process_zombify(struct process *process)&#10;{&#10;    int res = process_free_allocations(process);&#10;    ASSERT(res == 0, &quot;Failed to free allocations for process&quot;);&#10;&#10;    process_free_file_descriptors(process);&#10;&#10;    res = process_free_program_data(process);&#10;    ASSERT(res == 0, &quot;Failed to free program data for process&quot;);&#10;&#10;    if (process-&gt;user_stack) {&#10;        kfree(process-&gt;user_stack);&#10;    }&#10;    process-&gt;user_stack = nullptr;&#10;    if (process-&gt;thread) {&#10;        if (process-&gt;thread-&gt;kernel_stack) {&#10;            kfree(process-&gt;thread-&gt;kernel_stack);&#10;        }&#10;        kfree(process-&gt;thread);&#10;    }&#10;    process-&gt;thread = nullptr;&#10;    if (process-&gt;page_directory) {&#10;        paging_free_directory(process-&gt;page_directory);&#10;    }&#10;    process-&gt;page_directory = nullptr;&#10;&#10;    return res;&#10;}&#10;&#10;int process_count_command_arguments(const struct command_argument *root_argument)&#10;{&#10;    int i                                  = 0;&#10;    const struct command_argument *current = root_argument;&#10;    while (current) {&#10;        i++;&#10;        current = current-&gt;next;&#10;    }&#10;&#10;    return i;&#10;}&#10;&#10;int process_inject_arguments(struct process *process, const struct command_argument *root_argument)&#10;{&#10;    int res                                = 0;&#10;    const struct command_argument *current = root_argument;&#10;    int i                                  = 0;&#10;&#10;    const int argc = process_count_command_arguments(root_argument);&#10;&#10;    if (argc == 0) {&#10;        ASSERT(false, &quot;No arguments to inject&quot;);&#10;        res = -EINVARG;&#10;        goto out;&#10;    }&#10;&#10;    char **argv = process_malloc(process, sizeof(const char *) * argc);&#10;    if (!argv) {&#10;        ASSERT(false, &quot;Failed to allocate memory for arguments&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    while (current) {&#10;        char *argument_str = process_malloc(process, sizeof(current-&gt;argument));&#10;        if (!argument_str) {&#10;            ASSERT(false, &quot;Failed to allocate memory for argument string&quot;);&#10;            res = -ENOMEM;&#10;            goto out;&#10;        }&#10;&#10;        strncpy(argument_str, current-&gt;argument, sizeof(current-&gt;argument));&#10;        argv[i] = argument_str;&#10;        current = current-&gt;next;&#10;        i++;&#10;    }&#10;&#10;    process-&gt;arguments.argc = argc;&#10;    process-&gt;arguments.argv = argv;&#10;    process_set_current_directory(process, root_argument-&gt;current_directory);&#10;&#10;out:&#10;    return res;&#10;}&#10;&#10;void process_free(struct process *process, void *ptr)&#10;{&#10;    struct process_allocation *allocation = process_get_allocation_by_address(process, ptr);&#10;    if (!allocation) {&#10;        ASSERT(false, &quot;Failed to find allocation for address&quot;);&#10;        return;&#10;    }&#10;&#10;    const int res = paging_map_to(process-&gt;page_directory,&#10;                                  allocation-&gt;ptr,&#10;                                  allocation-&gt;ptr,&#10;                                  paging_align_address((char *)allocation-&gt;ptr + allocation-&gt;size),&#10;                                  PDE_UNMAPPED);&#10;&#10;    if (res &lt; 0) {&#10;        ASSERT(false, &quot;Failed to unmap memory&quot;);&#10;        return;&#10;    }&#10;&#10;    for (size_t i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (process-&gt;allocations[i].ptr == ptr) {&#10;            process-&gt;allocations[i].ptr  = NULL;&#10;            process-&gt;allocations[i].size = 0;&#10;&#10;            break;&#10;        }&#10;    }&#10;&#10;    kfree(ptr);&#10;}&#10;&#10;void *process_calloc(struct process *process, const size_t nmemb, const size_t size)&#10;{&#10;    void *ptr = process_malloc(process, nmemb * size);&#10;    if (!ptr) {&#10;        return NULL;&#10;    }&#10;&#10;    memset(ptr, 0x00, nmemb * size);&#10;    return ptr;&#10;}&#10;&#10;// Allocate memory accessible by the process&#10;void *process_malloc(struct process *process, const size_t size)&#10;{&#10;    void *ptr = kmalloc(size);&#10;    if (!ptr) {&#10;        ASSERT(false, &quot;Failed to allocate memory for process&quot;);&#10;        goto out_error;&#10;    }&#10;&#10;    const int index = process_find_free_allocation_slot(process);&#10;    if (index &lt; 0) {&#10;        ASSERT(false, &quot;Failed to find free allocation slot&quot;);&#10;        goto out_error;&#10;    }&#10;&#10;    const int res =&#10;        paging_map_to(process-&gt;page_directory,&#10;                      ptr,&#10;                      ptr,&#10;                      paging_align_address((char *)ptr + size),&#10;                      PDE_IS_PRESENT | PDE_IS_WRITABLE | PDE_SUPERVISOR); // TODO: Get rid of supervisor flag&#10;    if (res &lt; 0) {&#10;        ASSERT(false, &quot;Failed to map memory for process&quot;);&#10;        goto out_error;&#10;    }&#10;&#10;    process-&gt;allocations[index].ptr  = ptr;&#10;    process-&gt;allocations[index].size = size;&#10;&#10;    return ptr;&#10;&#10;out_error:&#10;    if (ptr) {&#10;        kfree(ptr);&#10;    }&#10;    return NULL;&#10;}&#10;&#10;void *process_realloc(struct process *process, void *ptr, const size_t size)&#10;{&#10;    struct process_allocation *allocation = process_get_allocation_by_address(process, ptr);&#10;    if (!allocation) {&#10;        ASSERT(false, &quot;Failed to find allocation for address&quot;);&#10;        return NULL;&#10;    }&#10;&#10;    void *new_ptr = process_malloc(process, size);&#10;    if (!new_ptr) {&#10;        ASSERT(false, &quot;Failed to allocate memory for reallocation&quot;);&#10;        return NULL;&#10;    }&#10;&#10;    memcpy(new_ptr, ptr, allocation-&gt;size);&#10;    process_free(process, ptr);&#10;&#10;    return new_ptr;&#10;}&#10;&#10;// ReSharper disable once CppDFAUnreachableFunctionCall&#10;static int process_load_binary(const char *file_name, struct process *process)&#10;{&#10;    dbgprintf(&quot;Loading binary %s\n&quot;, file_name);&#10;&#10;    void *program = nullptr;&#10;&#10;    int res      = 0;&#10;    const int fd = vfs_open(nullptr, file_name, O_RDONLY);&#10;    if (fd &lt; 0) {&#10;        warningf(&quot;Failed to open file %s\n&quot;, file_name);&#10;        res = -EIO;&#10;        goto out;&#10;    }&#10;&#10;    struct stat fstat;&#10;    res = vfs_stat(nullptr, fd, &amp;fstat);&#10;    if (res != ALL_OK) {&#10;        warningf(&quot;Failed to get file stat\n&quot;);&#10;        res = -EIO;&#10;        goto out;&#10;    }&#10;&#10;    program = kzalloc(fstat.st_size);&#10;    if (program == nullptr) {&#10;        ASSERT(false, &quot;Failed to allocate memory for program&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    if (vfs_read(nullptr, program, fstat.st_size, 1, fd) != (int)fstat.st_size) {&#10;        warningf(&quot;Failed to read file\n&quot;);&#10;        res = -EIO;&#10;        goto out;&#10;    }&#10;&#10;    process-&gt;file_type = PROCESS_FILE_TYPE_BINARY;&#10;    process-&gt;pointer   = program;&#10;    process-&gt;size      = fstat.st_size;&#10;&#10;out:&#10;    if (res &lt; 0) {&#10;        if (program != nullptr) {&#10;            kfree(program);&#10;        }&#10;    }&#10;    vfs_close(process, fd);&#10;    return res;&#10;}&#10;&#10;static int process_load_elf(const char *file_name, struct process *process)&#10;{&#10;    int res                   = 0;&#10;    struct elf_file *elf_file = nullptr;&#10;&#10;    res = elf_load(file_name, &amp;elf_file);&#10;    if (ISERR(res)) {&#10;        warningf(&quot;Failed to load ELF file\n&quot;);&#10;        warningf(&quot;Error code: %d\n&quot;, res);&#10;        goto out;&#10;    }&#10;&#10;    process-&gt;file_type = PROCESS_FILE_TYPE_ELF;&#10;    process-&gt;elf_file  = elf_file;&#10;    process-&gt;size      = elf_file-&gt;in_memory_size;&#10;&#10;out:&#10;    return res;&#10;}&#10;&#10;int process_load_data(const char file_name[static 1], struct process *process)&#10;{&#10;    int res = 0;&#10;&#10;    res = process_load_elf(file_name, process);&#10;    // ReSharper disable once CppDFAConstantConditions&#10;    if (res == -EINFORMAT) {&#10;        warningf(&quot;Failed to load ELF file, trying to load as binary\n&quot;);&#10;        res = process_load_binary(file_name, process);&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;static int process_map_binary(const struct process *process)&#10;{&#10;    return paging_map_to(process-&gt;page_directory,&#10;                         (void *)PROGRAM_VIRTUAL_ADDRESS,&#10;                         process-&gt;pointer,&#10;                         paging_align_address((char *)process-&gt;pointer + process-&gt;size),&#10;                         PDE_IS_PRESENT | PDE_IS_WRITABLE | PDE_SUPERVISOR);&#10;}&#10;&#10;static int process_unmap_binary(const struct process *process)&#10;{&#10;    return paging_map_to(process-&gt;page_directory,&#10;                         (void *)PROGRAM_VIRTUAL_ADDRESS,&#10;                         process-&gt;pointer,&#10;                         paging_align_address((char *)process-&gt;pointer + process-&gt;size),&#10;                         PDE_UNMAPPED);&#10;}&#10;&#10;static int process_map_elf(struct process *process)&#10;{&#10;    int res                         = 0;&#10;    const struct elf_file *elf_file = process-&gt;elf_file;&#10;    struct elf_header *header       = elf_header(elf_file);&#10;    const struct elf32_phdr *phdrs  = elf_pheader(header);&#10;&#10;    for (int i = 0; i &lt; header-&gt;e_phnum; i++) {&#10;        const struct elf32_phdr *phdr = &amp;phdrs[i];&#10;&#10;        if (phdr-&gt;p_type != PT_LOAD) {&#10;            continue; // Skip non-loadable segments&#10;        }&#10;&#10;        // Allocate new physical memory for the segment&#10;        void *phys_addr = process_malloc(process, phdr-&gt;p_memsz);&#10;        if (phys_addr == NULL) {&#10;            return -ENOMEM;&#10;        }&#10;&#10;        int flags = PDE_IS_PRESENT | PDE_SUPERVISOR; // TODO: Get rid of supervisor&#10;&#10;        if (phdr-&gt;p_flags &amp; PF_W) {&#10;            flags |= PDE_IS_WRITABLE;&#10;        }&#10;&#10;        res = paging_map_to(process-&gt;page_directory,&#10;                            paging_align_to_lower_page((void *)phdr-&gt;p_vaddr),&#10;                            paging_align_to_lower_page(phys_addr),&#10;                            paging_align_address((char *)phys_addr + phdr-&gt;p_memsz),&#10;                            flags);&#10;        if (ISERR(res)) {&#10;            ASSERT(false, &quot;Failed to map ELF segment&quot;);&#10;            kfree(phys_addr);&#10;            break;&#10;        }&#10;&#10;        // Copy segment data from the ELF file to the allocated memory&#10;        if (phdr-&gt;p_filesz &gt; 0) {&#10;            memcpy(phys_addr, (char *)elf_memory(elf_file) + phdr-&gt;p_offset, phdr-&gt;p_filesz);&#10;        }&#10;&#10;        // Zero-initialize the BSS section (p_memsz &gt; p_filesz)&#10;        if (phdr-&gt;p_memsz &gt; phdr-&gt;p_filesz) {&#10;            memset((char *)phys_addr + phdr-&gt;p_filesz, 0, phdr-&gt;p_memsz - phdr-&gt;p_filesz);&#10;        }&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;static int process_unmap_elf(const struct process *process)&#10;{&#10;    int res                         = 0;&#10;    const struct elf_file *elf_file = process-&gt;elf_file;&#10;    struct elf_header *header       = elf_header(elf_file);&#10;    const struct elf32_phdr *phdrs  = elf_pheader(header);&#10;&#10;    for (int i = 0; i &lt; header-&gt;e_phnum; i++) {&#10;        const struct elf32_phdr *phdr = &amp;phdrs[i];&#10;        void *phdr_phys_address       = elf_phdr_phys_address(elf_file, phdr);&#10;&#10;        res = paging_map_to(process-&gt;page_directory,&#10;                            paging_align_to_lower_page((void *)phdr-&gt;p_vaddr),&#10;                            paging_align_to_lower_page(phdr_phys_address),&#10;                            paging_align_address((char *)phdr_phys_address + phdr-&gt;p_memsz),&#10;                            PDE_UNMAPPED);&#10;        if (ISERR(res)) {&#10;            ASSERT(false, &quot;Failed to unmap ELF file&quot;);&#10;            break;&#10;        }&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;int process_map_memory(struct process *process)&#10;{&#10;    int res = 0;&#10;    switch (process-&gt;file_type) {&#10;    case PROCESS_FILE_TYPE_ELF:&#10;        res = process_map_elf(process);&#10;        break;&#10;    case PROCESS_FILE_TYPE_BINARY:&#10;        res = process_map_binary(process);&#10;        break;&#10;    default:&#10;        panic(&quot;Unknown process file type&quot;);&#10;        break;&#10;    }&#10;&#10;    ASSERT(res &gt;= 0, &quot;Failed to map memory for process&quot;);&#10;&#10;    // Map stack&#10;    res = paging_map_to(process-&gt;page_directory,&#10;                        (char *)USER_STACK_BOTTOM, // stack grows down&#10;                        process-&gt;user_stack,&#10;                        paging_align_address((char *)process-&gt;user_stack + USER_STACK_SIZE),&#10;                        PDE_IS_PRESENT | PDE_IS_WRITABLE | PDE_SUPERVISOR);&#10;&#10;&#10;out:&#10;    return res;&#10;}&#10;&#10;int process_unmap_memory(const struct process *process)&#10;{&#10;    int res = 0;&#10;    switch (process-&gt;file_type) {&#10;    case PROCESS_FILE_TYPE_ELF:&#10;        res = process_unmap_elf(process);&#10;        break;&#10;    case PROCESS_FILE_TYPE_BINARY:&#10;        res = process_unmap_binary(process);&#10;        break;&#10;    default:&#10;        panic(&quot;Unknown process file type&quot;);&#10;        break;&#10;    }&#10;&#10;    ASSERT(res &gt;= 0, &quot;Failed to unmap memory for process&quot;);&#10;&#10;    if (process-&gt;user_stack == nullptr) {&#10;        return res;&#10;    }&#10;&#10;    res = paging_map_to(process-&gt;page_directory,&#10;                        (char *)USER_STACK_BOTTOM, // stack grows down&#10;                        process-&gt;user_stack,&#10;                        paging_align_address((char *)process-&gt;user_stack + USER_STACK_SIZE),&#10;                        PDE_UNMAPPED);&#10;    return res;&#10;}&#10;&#10;&#10;int process_load_enqueue(const char file_name[static 1], struct process **process)&#10;{&#10;    const int res = process_load(file_name, process);&#10;    if (res == 0) {&#10;        (*process)-&gt;thread-&gt;wakeup_time = -1;&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;int process_load(const char file_name[static 1], struct process **process)&#10;{&#10;    int res       = 0;&#10;    const int pid = process_get_free_pid();&#10;    if (pid &lt; 0) {&#10;        warningf(&quot;Failed to get free process slot\n&quot;);&#10;        ASSERT(false, &quot;Failed to get free process slot&quot;);&#10;        res = -EINSTKN;&#10;        goto out;&#10;    }&#10;&#10;    res = process_load_for_slot(file_name, process, pid);&#10;&#10;    acquire(&amp;process_list.lock);&#10;    process_set(pid, *process);&#10;    release(&amp;process_list.lock);&#10;out:&#10;    return res;&#10;}&#10;&#10;int process_load_for_slot(const char file_name[static 1], struct process **process, const uint16_t pid)&#10;{&#10;    int res                     = 0;&#10;    struct thread *thread       = nullptr;&#10;    struct process *proc        = nullptr;&#10;    void *program_stack_pointer = nullptr;&#10;&#10;    if (process_get(pid) != nullptr) {&#10;        panic(&quot;Process slot is not empty\n&quot;);&#10;        res = -EINSTKN;&#10;        goto out;&#10;    }&#10;&#10;    proc = kzalloc(sizeof(struct process));&#10;    if (!proc) {&#10;        panic(&quot;Failed to allocate memory for process\n&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    res = process_load_data(file_name, proc);&#10;    if (res &lt; 0) {&#10;        warningf(&quot;Failed to load data for process\n&quot;);&#10;        goto out;&#10;    }&#10;&#10;    program_stack_pointer = kzalloc(USER_STACK_SIZE);&#10;    if (!program_stack_pointer) {&#10;        panic(&quot;Failed to allocate memory for program stack\n&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    strncpy(proc-&gt;file_name, file_name, sizeof(proc-&gt;file_name));&#10;    proc-&gt;user_stack = program_stack_pointer;&#10;    proc-&gt;pid        = pid;&#10;&#10;    thread = thread_create(proc);&#10;    if (ISERR(thread)) {&#10;        panic(&quot;Failed to create thread\n&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    proc-&gt;thread  = thread;&#10;    proc-&gt;rand_id = (int)get_random();&#10;&#10;    res = process_map_memory(proc);&#10;    if (res &lt; 0) {&#10;        panic(&quot;Failed to map memory for process\n&quot;);&#10;        goto out;&#10;    }&#10;&#10;    memset(proc-&gt;file_descriptors, 0, sizeof(proc-&gt;file_descriptors));&#10;    *process = proc;&#10;&#10;out:&#10;    if (ISERR(res)) {&#10;        if (proc) {&#10;            process_zombify(proc);&#10;            kfree(proc);&#10;        }&#10;    }&#10;    return res;&#10;}&#10;&#10;int process_set_current_directory(struct process *process, const char directory[static 1])&#10;{&#10;    if (strlen(directory) == 0) {&#10;        return -EINVARG;&#10;    }&#10;&#10;    if (process-&gt;current_directory == NULL) {&#10;        process-&gt;current_directory = process_malloc(process, MAX_PATH_LENGTH);&#10;    }&#10;&#10;    strncpy(process-&gt;current_directory, directory, MAX_PATH_LENGTH);&#10;&#10;    return ALL_OK;&#10;}&#10;&#10;int process_copy_allocations(struct process *dest, const struct process *src)&#10;{&#10;    memset(dest-&gt;allocations, 0, sizeof(dest-&gt;allocations));&#10;&#10;    for (size_t i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (src-&gt;allocations[i].ptr) {&#10;            void *ptr = process_malloc(dest, src-&gt;allocations[i].size);&#10;            if (!ptr) {&#10;                return -ENOMEM;&#10;            }&#10;&#10;            memcpy(ptr, src-&gt;allocations[i].ptr, src-&gt;allocations[i].size);&#10;            dest-&gt;allocations[i].ptr = ptr;&#10;        }&#10;    }&#10;&#10;    return ALL_OK;&#10;}&#10;&#10;void process_copy_stack(struct process *dest, const struct process *src)&#10;{&#10;    dest-&gt;user_stack = kzalloc(USER_STACK_SIZE);&#10;    memcpy(dest-&gt;user_stack, src-&gt;user_stack, USER_STACK_SIZE);&#10;    memcpy(dest-&gt;thread-&gt;kernel_stack, src-&gt;thread-&gt;kernel_stack, KERNEL_STACK_SIZE);&#10;}&#10;&#10;void process_copy_file_info(struct process *dest, const struct process *src)&#10;{&#10;    memcpy(dest-&gt;file_name, src-&gt;file_name, sizeof(src-&gt;file_name));&#10;    dest-&gt;file_type = src-&gt;file_type;&#10;    if (dest-&gt;file_type == PROCESS_FILE_TYPE_ELF) {&#10;        dest-&gt;elf_file             = kzalloc(sizeof(struct elf_file));&#10;        dest-&gt;elf_file-&gt;elf_memory = kzalloc(src-&gt;elf_file-&gt;in_memory_size);&#10;        memcpy(dest-&gt;elf_file-&gt;elf_memory, src-&gt;elf_file-&gt;elf_memory, src-&gt;elf_file-&gt;in_memory_size);&#10;        dest-&gt;elf_file-&gt;in_memory_size = src-&gt;elf_file-&gt;in_memory_size;&#10;        strncpy(dest-&gt;elf_file-&gt;filename, src-&gt;elf_file-&gt;filename, sizeof(src-&gt;elf_file-&gt;filename));&#10;        dest-&gt;elf_file-&gt;virtual_base_address = src-&gt;elf_file-&gt;virtual_base_address;&#10;        dest-&gt;elf_file-&gt;virtual_end_address  = src-&gt;elf_file-&gt;virtual_end_address;&#10;&#10;        const int res = elf_process_loaded(dest-&gt;elf_file);&#10;        if (res &lt; 0) {&#10;            panic(&quot;Failed to process loaded ELF file&quot;);&#10;        }&#10;&#10;    } else {&#10;        dest-&gt;pointer = kzalloc(src-&gt;size);&#10;        memcpy(dest-&gt;pointer, src-&gt;pointer, src-&gt;size);&#10;    }&#10;    dest-&gt;size = src-&gt;size;&#10;}&#10;&#10;void process_copy_arguments(struct process *dest, const struct process *src)&#10;{&#10;    dest-&gt;current_directory = process_malloc(dest, MAX_PATH_LENGTH);&#10;    memcpy(dest-&gt;current_directory, src-&gt;current_directory, MAX_PATH_LENGTH);&#10;&#10;    dest-&gt;arguments.argv = process_malloc(dest, sizeof(char *) * src-&gt;arguments.argc);&#10;    for (int i = 0; i &lt; src-&gt;arguments.argc; i++) {&#10;        dest-&gt;arguments.argv[i] = process_malloc(dest, strlen(src-&gt;arguments.argv[i]) + 1);&#10;        strncpy(dest-&gt;arguments.argv[i], src-&gt;arguments.argv[i], strlen(src-&gt;arguments.argv[i]) + 1);&#10;    }&#10;}&#10;&#10;void process_copy_thread(struct process *dest, const struct process *src)&#10;{&#10;    struct thread *thread = thread_create(dest);&#10;    if (ISERR(thread)) {&#10;        panic(&quot;Failed to create thread&quot;);&#10;    }&#10;&#10;    dest-&gt;thread            = thread;&#10;    dest-&gt;thread-&gt;process   = dest;&#10;    dest-&gt;thread-&gt;time_used = 0;&#10;&#10;    dest-&gt;thread-&gt;context-&gt;ebp = src-&gt;thread-&gt;context-&gt;ebp;&#10;    dest-&gt;thread-&gt;context-&gt;ebx = src-&gt;thread-&gt;context-&gt;ebx;&#10;    dest-&gt;thread-&gt;context-&gt;esi = src-&gt;thread-&gt;context-&gt;esi;&#10;    dest-&gt;thread-&gt;context-&gt;edi = src-&gt;thread-&gt;context-&gt;edi;&#10;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;cs     = src-&gt;thread-&gt;trap_frame-&gt;cs;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;ds     = src-&gt;thread-&gt;trap_frame-&gt;ds;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;es     = src-&gt;thread-&gt;trap_frame-&gt;es;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;fs     = src-&gt;thread-&gt;trap_frame-&gt;fs;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;gs     = src-&gt;thread-&gt;trap_frame-&gt;gs;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;ss     = src-&gt;thread-&gt;trap_frame-&gt;ss;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;eflags = src-&gt;thread-&gt;trap_frame-&gt;eflags;&#10;    // dest-&gt;thread-&gt;trap_frame-&gt;eip              = src-&gt;thread-&gt;trap_frame-&gt;eip;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;esp              = src-&gt;thread-&gt;trap_frame-&gt;esp;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;interrupt_number = src-&gt;thread-&gt;trap_frame-&gt;interrupt_number;&#10;}&#10;&#10;void process_copy_file_descriptors(struct process *dest, struct process *src)&#10;{&#10;    for (int i = 0; i &lt; MAX_FILE_DESCRIPTORS; i++) {&#10;        if (src-&gt;file_descriptors[i]) {&#10;            struct file *desc = kzalloc(sizeof(struct file));&#10;            if (!desc) {&#10;                panic(&quot;Failed to allocate memory for file descriptor&quot;);&#10;            }&#10;&#10;            memcpy(desc, src-&gt;file_descriptors[i], sizeof(struct file));&#10;            dest-&gt;file_descriptors[i] = desc;&#10;        }&#10;    }&#10;}&#10;&#10;struct process *process_clone(struct process *process)&#10;{&#10;    struct process *clone = kzalloc(sizeof(struct process));&#10;&#10;    if (!clone) {&#10;        panic(&quot;Failed to allocate memory for process clone&quot;);&#10;        return nullptr;&#10;    }&#10;&#10;    const int pid = process_get_free_pid();&#10;    if (pid &lt; 0) {&#10;        kfree(clone);&#10;        panic(&quot;No free process slot&quot;);&#10;        return nullptr;&#10;    }&#10;&#10;    clone-&gt;pid    = pid;&#10;    clone-&gt;parent = process;&#10;&#10;    // This is not super efficient&#10;&#10;    process_copy_file_descriptors(clone, process);&#10;    process_copy_file_info(clone, process);&#10;    process_copy_thread(clone, process);&#10;    process_copy_stack(clone, process);&#10;    process_copy_arguments(clone, process);&#10;    process_map_memory(clone);&#10;    process_copy_allocations(clone, process);&#10;&#10;    acquire(&amp;process_list.lock);&#10;    process_set(clone-&gt;pid, clone);&#10;    release(&amp;process_list.lock);&#10;&#10;    clone-&gt;rand_id = (int)get_random();&#10;&#10;    return clone;&#10;}&#10;&#10;void process_command_argument_free(struct command_argument *argument)&#10;{&#10;    if (argument-&gt;next) {&#10;        process_command_argument_free(argument-&gt;next);&#10;    }&#10;    kfree(argument);&#10;}&#10;&#10;void process_free_file_descriptor(struct process *process, struct file *desc)&#10;{&#10;    process-&gt;file_descriptors[desc-&gt;index] = nullptr;&#10;    // Do not free device inodes&#10;    if (desc-&gt;inode &amp;&amp; desc-&gt;inode-&gt;type != INODE_DEVICE &amp;&amp; desc-&gt;fs_type != FS_TYPE_RAMFS) {&#10;        if (desc-&gt;inode-&gt;data) {&#10;            kfree(desc-&gt;inode-&gt;data);&#10;        }&#10;        kfree(desc-&gt;inode);&#10;    }&#10;    kfree(desc);&#10;}&#10;&#10;int process_new_file_descriptor(struct process *process, struct file **desc_out)&#10;{&#10;    int res = -ENOMEM;&#10;    for (int i = 0; i &lt; MAX_FILE_DESCRIPTORS; i++) {&#10;        if (process-&gt;file_descriptors[i] == nullptr) {&#10;            struct file *desc = kzalloc(sizeof(struct file));&#10;            if (desc == nullptr) {&#10;                panic(&quot;Failed to allocate memory for file descriptor\n&quot;);&#10;                res = -ENOMEM;&#10;                break;&#10;            }&#10;&#10;            desc-&gt;index                  = i;&#10;            process-&gt;file_descriptors[i] = desc;&#10;            *desc_out                    = desc;&#10;            res                          = 0;&#10;            break;&#10;        }&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;struct file *process_get_file_descriptor(const struct process *process, const uint32_t index)&#10;{&#10;    if (index &gt; MAX_FILE_DESCRIPTORS - 1) {&#10;        return nullptr;&#10;    }&#10;&#10;    return process-&gt;file_descriptors[index];&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;assert.h&gt;&#10;#include &lt;debug.h&gt;&#10;#include &lt;elf.h&gt;&#10;#include &lt;idt.h&gt;&#10;#include &lt;kernel.h&gt;&#10;#include &lt;kernel_heap.h&gt;&#10;#include &lt;memory.h&gt;&#10;#include &lt;paging.h&gt;&#10;#include &lt;process.h&gt;&#10;#include &lt;rand.h&gt;&#10;#include &lt;serial.h&gt;&#10;#include &lt;spinlock.h&gt;&#10;#include &lt;status.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;sys/stat.h&gt;&#10;#include &lt;thread.h&gt;&#10;#include &lt;vfs.h&gt;&#10;&#10;extern struct process_list process_list;&#10;&#10;struct process *current_process(void)&#10;{&#10;    pushcli();&#10;    const struct thread *current_task = get_current_thread();&#10;    if (current_task) {&#10;        popcli();&#10;        return current_task-&gt;process;&#10;    }&#10;&#10;    popcli();&#10;    return nullptr;&#10;}&#10;&#10;static int process_find_free_allocation_slot(const struct process *process)&#10;{&#10;    for (int i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (process-&gt;allocations[i].ptr == NULL) {&#10;            return i;&#10;        }&#10;    }&#10;&#10;    panic(&quot;Failed to find free allocation slot&quot;);&#10;    return -ENOMEM;&#10;}&#10;&#10;static struct process_allocation *process_get_allocation_by_address(struct process *process, const void *address)&#10;{&#10;    for (int i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (process-&gt;allocations[i].ptr == address) {&#10;            return &amp;process-&gt;allocations[i];&#10;        }&#10;    }&#10;&#10;    return nullptr;&#10;}&#10;&#10;int process_free_allocations(struct process *process)&#10;{&#10;    for (int i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (process-&gt;allocations[i].ptr == nullptr) {&#10;            continue;&#10;        }&#10;        process_free(process, process-&gt;allocations[i].ptr);&#10;    }&#10;&#10;    return 0;&#10;}&#10;&#10;int process_free_program_data(const struct process *process)&#10;{&#10;    int res = 0;&#10;    switch (process-&gt;file_type) {&#10;    case PROCESS_FILE_TYPE_BINARY:&#10;        if (process-&gt;pointer) {&#10;            kfree(process-&gt;pointer);&#10;        }&#10;        break;&#10;&#10;    case PROCESS_FILE_TYPE_ELF:&#10;        if (process-&gt;elf_file) {&#10;            elf_close(process-&gt;elf_file);&#10;        }&#10;        break;&#10;&#10;    default:&#10;        ASSERT(false, &quot;Unknown process file type&quot;);&#10;        res = -EINVARG;&#10;    }&#10;    return res;&#10;}&#10;&#10;void process_free_file_descriptors(struct process *process)&#10;{&#10;    for (int i = 0; i &lt; MAX_FILE_DESCRIPTORS; i++) {&#10;        if (process-&gt;file_descriptors[i]) {&#10;            vfs_close(process, i);&#10;        }&#10;    }&#10;}&#10;&#10;/// @brief Turn the process into a zombie and deallocates its resources&#10;/// The process remains in the process list until the parent process reads the exit code&#10;int process_zombify(struct process *process)&#10;{&#10;    int res = process_free_allocations(process);&#10;    ASSERT(res == 0, &quot;Failed to free allocations for process&quot;);&#10;&#10;    process_free_file_descriptors(process);&#10;&#10;    res = process_free_program_data(process);&#10;    ASSERT(res == 0, &quot;Failed to free program data for process&quot;);&#10;&#10;    if (process-&gt;user_stack) {&#10;        kfree(process-&gt;user_stack);&#10;    }&#10;    process-&gt;user_stack = nullptr;&#10;    if (process-&gt;thread) {&#10;        if (process-&gt;thread-&gt;kernel_stack) {&#10;            kfree(process-&gt;thread-&gt;kernel_stack);&#10;        }&#10;        kfree(process-&gt;thread);&#10;    }&#10;    process-&gt;thread = nullptr;&#10;    if (process-&gt;page_directory) {&#10;        paging_free_directory(process-&gt;page_directory);&#10;    }&#10;    process-&gt;page_directory = nullptr;&#10;&#10;    return res;&#10;}&#10;&#10;int process_count_command_arguments(const struct command_argument *root_argument)&#10;{&#10;    int i                                  = 0;&#10;    const struct command_argument *current = root_argument;&#10;    while (current) {&#10;        i++;&#10;        current = current-&gt;next;&#10;    }&#10;&#10;    return i;&#10;}&#10;&#10;int process_inject_arguments(struct process *process, const struct command_argument *root_argument)&#10;{&#10;    int res                                = 0;&#10;    const struct command_argument *current = root_argument;&#10;    int i                                  = 0;&#10;&#10;    const int argc = process_count_command_arguments(root_argument);&#10;&#10;    if (argc == 0) {&#10;        ASSERT(false, &quot;No arguments to inject&quot;);&#10;        res = -EINVARG;&#10;        goto out;&#10;    }&#10;&#10;    char **argv = process_malloc(process, sizeof(const char *) * argc);&#10;    if (!argv) {&#10;        ASSERT(false, &quot;Failed to allocate memory for arguments&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    while (current) {&#10;        char *argument_str = process_malloc(process, sizeof(current-&gt;argument));&#10;        if (!argument_str) {&#10;            ASSERT(false, &quot;Failed to allocate memory for argument string&quot;);&#10;            res = -ENOMEM;&#10;            goto out;&#10;        }&#10;&#10;        strncpy(argument_str, current-&gt;argument, sizeof(current-&gt;argument));&#10;        argv[i] = argument_str;&#10;        current = current-&gt;next;&#10;        i++;&#10;    }&#10;&#10;    process-&gt;arguments.argc = argc;&#10;    process-&gt;arguments.argv = argv;&#10;    process_set_current_directory(process, root_argument-&gt;current_directory);&#10;&#10;out:&#10;    return res;&#10;}&#10;&#10;void process_free(struct process *process, void *ptr)&#10;{&#10;    struct process_allocation *allocation = process_get_allocation_by_address(process, ptr);&#10;    if (!allocation) {&#10;        ASSERT(false, &quot;Failed to find allocation for address&quot;);&#10;        return;&#10;    }&#10;&#10;    const int res = paging_map_to(process-&gt;page_directory,&#10;                                  allocation-&gt;ptr,&#10;                                  allocation-&gt;ptr,&#10;                                  paging_align_address((char *)allocation-&gt;ptr + allocation-&gt;size),&#10;                                  PDE_UNMAPPED);&#10;&#10;    if (res &lt; 0) {&#10;        ASSERT(false, &quot;Failed to unmap memory&quot;);&#10;        return;&#10;    }&#10;&#10;    for (size_t i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (process-&gt;allocations[i].ptr == ptr) {&#10;            process-&gt;allocations[i].ptr  = NULL;&#10;            process-&gt;allocations[i].size = 0;&#10;&#10;            break;&#10;        }&#10;    }&#10;&#10;    kfree(ptr);&#10;}&#10;&#10;void *process_calloc(struct process *process, const size_t nmemb, const size_t size)&#10;{&#10;    void *ptr = process_malloc(process, nmemb * size);&#10;    if (!ptr) {&#10;        return NULL;&#10;    }&#10;&#10;    memset(ptr, 0x00, nmemb * size);&#10;    return ptr;&#10;}&#10;&#10;// Allocate memory accessible by the process&#10;void *process_malloc(struct process *process, const size_t size)&#10;{&#10;    void *ptr = kmalloc(size);&#10;    if (!ptr) {&#10;        ASSERT(false, &quot;Failed to allocate memory for process&quot;);&#10;        goto out_error;&#10;    }&#10;&#10;    const int index = process_find_free_allocation_slot(process);&#10;    if (index &lt; 0) {&#10;        ASSERT(false, &quot;Failed to find free allocation slot&quot;);&#10;        goto out_error;&#10;    }&#10;&#10;    const int res =&#10;        paging_map_to(process-&gt;page_directory,&#10;                      ptr,&#10;                      ptr,&#10;                      paging_align_address((char *)ptr + size),&#10;                      PDE_IS_PRESENT | PDE_IS_WRITABLE | PDE_SUPERVISOR); // TODO: Get rid of supervisor flag&#10;    if (res &lt; 0) {&#10;        ASSERT(false, &quot;Failed to map memory for process&quot;);&#10;        goto out_error;&#10;    }&#10;&#10;    process-&gt;allocations[index].ptr  = ptr;&#10;    process-&gt;allocations[index].size = size;&#10;&#10;    return ptr;&#10;&#10;out_error:&#10;    if (ptr) {&#10;        kfree(ptr);&#10;    }&#10;    return NULL;&#10;}&#10;&#10;void *process_realloc(struct process *process, void *ptr, const size_t size)&#10;{&#10;    struct process_allocation *allocation = process_get_allocation_by_address(process, ptr);&#10;    if (!allocation) {&#10;        ASSERT(false, &quot;Failed to find allocation for address&quot;);&#10;        return NULL;&#10;    }&#10;&#10;    void *new_ptr = process_malloc(process, size);&#10;    if (!new_ptr) {&#10;        ASSERT(false, &quot;Failed to allocate memory for reallocation&quot;);&#10;        return NULL;&#10;    }&#10;&#10;    memcpy(new_ptr, ptr, allocation-&gt;size);&#10;    process_free(process, ptr);&#10;&#10;    return new_ptr;&#10;}&#10;&#10;// ReSharper disable once CppDFAUnreachableFunctionCall&#10;static int process_load_binary(const char *file_name, struct process *process)&#10;{&#10;    dbgprintf(&quot;Loading binary %s\n&quot;, file_name);&#10;&#10;    void *program = nullptr;&#10;&#10;    int res      = 0;&#10;    const int fd = vfs_open(nullptr, file_name, O_RDONLY);&#10;    if (fd &lt; 0) {&#10;        warningf(&quot;Failed to open file %s\n&quot;, file_name);&#10;        res = -EIO;&#10;        goto out;&#10;    }&#10;&#10;    struct stat fstat;&#10;    res = vfs_stat(nullptr, fd, &amp;fstat);&#10;    if (res != ALL_OK) {&#10;        warningf(&quot;Failed to get file stat\n&quot;);&#10;        res = -EIO;&#10;        goto out;&#10;    }&#10;&#10;    program = kzalloc(fstat.st_size);&#10;    if (program == nullptr) {&#10;        ASSERT(false, &quot;Failed to allocate memory for program&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    if (vfs_read(nullptr, program, fstat.st_size, 1, fd) != (int)fstat.st_size) {&#10;        warningf(&quot;Failed to read file\n&quot;);&#10;        res = -EIO;&#10;        goto out;&#10;    }&#10;&#10;    process-&gt;file_type = PROCESS_FILE_TYPE_BINARY;&#10;    process-&gt;pointer   = program;&#10;    process-&gt;size      = fstat.st_size;&#10;&#10;out:&#10;    if (res &lt; 0) {&#10;        if (program != nullptr) {&#10;            kfree(program);&#10;        }&#10;    }&#10;    vfs_close(process, fd);&#10;    return res;&#10;}&#10;&#10;static int process_load_elf(const char *file_name, struct process *process)&#10;{&#10;    int res                   = 0;&#10;    struct elf_file *elf_file = nullptr;&#10;&#10;    res = elf_load(file_name, &amp;elf_file);&#10;    if (ISERR(res)) {&#10;        warningf(&quot;Failed to load ELF file\n&quot;);&#10;        warningf(&quot;Error code: %d\n&quot;, res);&#10;        goto out;&#10;    }&#10;&#10;    process-&gt;file_type = PROCESS_FILE_TYPE_ELF;&#10;    process-&gt;elf_file  = elf_file;&#10;    process-&gt;size      = elf_file-&gt;in_memory_size;&#10;&#10;out:&#10;    return res;&#10;}&#10;&#10;int process_load_data(const char file_name[static 1], struct process *process)&#10;{&#10;    int res = 0;&#10;&#10;    res = process_load_elf(file_name, process);&#10;    // ReSharper disable once CppDFAConstantConditions&#10;    if (res == -EINFORMAT) {&#10;        warningf(&quot;Failed to load ELF file, trying to load as binary\n&quot;);&#10;        res = process_load_binary(file_name, process);&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;static int process_map_binary(const struct process *process)&#10;{&#10;    return paging_map_to(process-&gt;page_directory,&#10;                         (void *)PROGRAM_VIRTUAL_ADDRESS,&#10;                         process-&gt;pointer,&#10;                         paging_align_address((char *)process-&gt;pointer + process-&gt;size),&#10;                         PDE_IS_PRESENT | PDE_IS_WRITABLE | PDE_SUPERVISOR);&#10;}&#10;&#10;static int process_unmap_binary(const struct process *process)&#10;{&#10;    return paging_map_to(process-&gt;page_directory,&#10;                         (void *)PROGRAM_VIRTUAL_ADDRESS,&#10;                         process-&gt;pointer,&#10;                         paging_align_address((char *)process-&gt;pointer + process-&gt;size),&#10;                         PDE_UNMAPPED);&#10;}&#10;&#10;static int process_map_elf(struct process *process)&#10;{&#10;    int res                         = 0;&#10;    const struct elf_file *elf_file = process-&gt;elf_file;&#10;    struct elf_header *header       = elf_header(elf_file);&#10;    const struct elf32_phdr *phdrs  = elf_pheader(header);&#10;&#10;    for (int i = 0; i &lt; header-&gt;e_phnum; i++) {&#10;        const struct elf32_phdr *phdr = &amp;phdrs[i];&#10;&#10;        if (phdr-&gt;p_type != PT_LOAD) {&#10;            continue; // Skip non-loadable segments&#10;        }&#10;&#10;        // Allocate new physical memory for the segment&#10;        void *phys_addr = process_malloc(process, phdr-&gt;p_memsz);&#10;        if (phys_addr == NULL) {&#10;            return -ENOMEM;&#10;        }&#10;&#10;        int flags = PDE_IS_PRESENT | PDE_SUPERVISOR; // TODO: Get rid of supervisor&#10;&#10;        if (phdr-&gt;p_flags &amp; PF_W) {&#10;            flags |= PDE_IS_WRITABLE;&#10;        }&#10;&#10;        res = paging_map_to(process-&gt;page_directory,&#10;                            paging_align_to_lower_page((void *)phdr-&gt;p_vaddr),&#10;                            paging_align_to_lower_page(phys_addr),&#10;                            paging_align_address((char *)phys_addr + phdr-&gt;p_memsz),&#10;                            flags);&#10;        if (ISERR(res)) {&#10;            ASSERT(false, &quot;Failed to map ELF segment&quot;);&#10;            kfree(phys_addr);&#10;            break;&#10;        }&#10;&#10;        // Copy segment data from the ELF file to the allocated memory&#10;        if (phdr-&gt;p_filesz &gt; 0) {&#10;            memcpy(phys_addr, (char *)elf_memory(elf_file) + phdr-&gt;p_offset, phdr-&gt;p_filesz);&#10;        }&#10;&#10;        // Zero-initialize the BSS section (p_memsz &gt; p_filesz)&#10;        if (phdr-&gt;p_memsz &gt; phdr-&gt;p_filesz) {&#10;            memset((char *)phys_addr + phdr-&gt;p_filesz, 0, phdr-&gt;p_memsz - phdr-&gt;p_filesz);&#10;        }&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;static int process_unmap_elf(const struct process *process)&#10;{&#10;    int res                         = 0;&#10;    const struct elf_file *elf_file = process-&gt;elf_file;&#10;    struct elf_header *header       = elf_header(elf_file);&#10;    const struct elf32_phdr *phdrs  = elf_pheader(header);&#10;&#10;    for (int i = 0; i &lt; header-&gt;e_phnum; i++) {&#10;        const struct elf32_phdr *phdr = &amp;phdrs[i];&#10;        void *phdr_phys_address       = elf_phdr_phys_address(elf_file, phdr);&#10;&#10;        res = paging_map_to(process-&gt;page_directory,&#10;                            paging_align_to_lower_page((void *)phdr-&gt;p_vaddr),&#10;                            paging_align_to_lower_page(phdr_phys_address),&#10;                            paging_align_address((char *)phdr_phys_address + phdr-&gt;p_memsz),&#10;                            PDE_UNMAPPED);&#10;        if (ISERR(res)) {&#10;            ASSERT(false, &quot;Failed to unmap ELF file&quot;);&#10;            break;&#10;        }&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;int process_map_memory(struct process *process)&#10;{&#10;    int res = 0;&#10;    switch (process-&gt;file_type) {&#10;    case PROCESS_FILE_TYPE_ELF:&#10;        res = process_map_elf(process);&#10;        break;&#10;    case PROCESS_FILE_TYPE_BINARY:&#10;        res = process_map_binary(process);&#10;        break;&#10;    default:&#10;        panic(&quot;Unknown process file type&quot;);&#10;        break;&#10;    }&#10;&#10;    ASSERT(res &gt;= 0, &quot;Failed to map memory for process&quot;);&#10;&#10;    // Map stack&#10;    res = paging_map_to(process-&gt;page_directory,&#10;                        (char *)USER_STACK_BOTTOM, // stack grows down&#10;                        process-&gt;user_stack,&#10;                        paging_align_address((char *)process-&gt;user_stack + USER_STACK_SIZE),&#10;                        PDE_IS_PRESENT | PDE_IS_WRITABLE | PDE_SUPERVISOR);&#10;&#10;&#10;out:&#10;    return res;&#10;}&#10;&#10;int process_unmap_memory(const struct process *process)&#10;{&#10;    int res = 0;&#10;    switch (process-&gt;file_type) {&#10;    case PROCESS_FILE_TYPE_ELF:&#10;        res = process_unmap_elf(process);&#10;        break;&#10;    case PROCESS_FILE_TYPE_BINARY:&#10;        res = process_unmap_binary(process);&#10;        break;&#10;    default:&#10;        panic(&quot;Unknown process file type&quot;);&#10;        break;&#10;    }&#10;&#10;    ASSERT(res &gt;= 0, &quot;Failed to unmap memory for process&quot;);&#10;&#10;    if (process-&gt;user_stack == nullptr) {&#10;        return res;&#10;    }&#10;&#10;    res = paging_map_to(process-&gt;page_directory,&#10;                        (char *)USER_STACK_BOTTOM, // stack grows down&#10;                        process-&gt;user_stack,&#10;                        paging_align_address((char *)process-&gt;user_stack + USER_STACK_SIZE),&#10;                        PDE_UNMAPPED);&#10;    return res;&#10;}&#10;&#10;&#10;int process_load_enqueue(const char file_name[static 1], struct process **process)&#10;{&#10;    const int res = process_load(file_name, process);&#10;    if (res == 0) {&#10;        (*process)-&gt;thread-&gt;wakeup_time = -1;&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;int process_load(const char file_name[static 1], struct process **process)&#10;{&#10;    int res       = 0;&#10;    const int pid = process_get_free_pid();&#10;    if (pid &lt; 0) {&#10;        warningf(&quot;Failed to get free process slot\n&quot;);&#10;        ASSERT(false, &quot;Failed to get free process slot&quot;);&#10;        res = -EINSTKN;&#10;        goto out;&#10;    }&#10;&#10;    res = process_load_for_slot(file_name, process, pid);&#10;&#10;    acquire(&amp;process_list.lock);&#10;    process_set(pid, *process);&#10;    release(&amp;process_list.lock);&#10;out:&#10;    return res;&#10;}&#10;&#10;int process_load_for_slot(const char file_name[static 1], struct process **process, const uint16_t pid)&#10;{&#10;    int res                     = 0;&#10;    struct thread *thread       = nullptr;&#10;    struct process *proc        = nullptr;&#10;    void *program_stack_pointer = nullptr;&#10;&#10;    if (process_get(pid) != nullptr) {&#10;        panic(&quot;Process slot is not empty\n&quot;);&#10;        res = -EINSTKN;&#10;        goto out;&#10;    }&#10;&#10;    proc = kzalloc(sizeof(struct process));&#10;    if (!proc) {&#10;        panic(&quot;Failed to allocate memory for process\n&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    res = process_load_data(file_name, proc);&#10;    if (res &lt; 0) {&#10;        warningf(&quot;Failed to load data for process\n&quot;);&#10;        goto out;&#10;    }&#10;&#10;    program_stack_pointer = kzalloc(USER_STACK_SIZE);&#10;    if (!program_stack_pointer) {&#10;        panic(&quot;Failed to allocate memory for program stack\n&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    strncpy(proc-&gt;file_name, file_name, sizeof(proc-&gt;file_name));&#10;    proc-&gt;user_stack = program_stack_pointer;&#10;    proc-&gt;pid        = pid;&#10;&#10;    thread = thread_create(proc);&#10;    if (ISERR(thread)) {&#10;        panic(&quot;Failed to create thread\n&quot;);&#10;        res = -ENOMEM;&#10;        goto out;&#10;    }&#10;&#10;    proc-&gt;thread  = thread;&#10;    proc-&gt;rand_id = (int)get_random();&#10;&#10;    res = process_map_memory(proc);&#10;    if (res &lt; 0) {&#10;        panic(&quot;Failed to map memory for process\n&quot;);&#10;        goto out;&#10;    }&#10;&#10;    memset(proc-&gt;file_descriptors, 0, sizeof(proc-&gt;file_descriptors));&#10;    *process = proc;&#10;&#10;out:&#10;    if (ISERR(res)) {&#10;        if (proc) {&#10;            process_zombify(proc);&#10;            kfree(proc);&#10;        }&#10;    }&#10;    return res;&#10;}&#10;&#10;int process_set_current_directory(struct process *process, const char directory[static 1])&#10;{&#10;    if (strlen(directory) == 0) {&#10;        return -EINVARG;&#10;    }&#10;&#10;    if (process-&gt;current_directory == NULL) {&#10;        process-&gt;current_directory = process_malloc(process, MAX_PATH_LENGTH);&#10;    }&#10;&#10;    strncpy(process-&gt;current_directory, directory, MAX_PATH_LENGTH);&#10;&#10;    return ALL_OK;&#10;}&#10;&#10;int process_copy_allocations(struct process *dest, const struct process *src)&#10;{&#10;    memset(dest-&gt;allocations, 0, sizeof(dest-&gt;allocations));&#10;&#10;    for (size_t i = 0; i &lt; MAX_PROGRAM_ALLOCATIONS; i++) {&#10;        if (src-&gt;allocations[i].ptr) {&#10;            void *ptr = process_malloc(dest, src-&gt;allocations[i].size);&#10;            if (!ptr) {&#10;                return -ENOMEM;&#10;            }&#10;&#10;            memcpy(ptr, src-&gt;allocations[i].ptr, src-&gt;allocations[i].size);&#10;            dest-&gt;allocations[i].ptr = ptr;&#10;        }&#10;    }&#10;&#10;    return ALL_OK;&#10;}&#10;&#10;void process_copy_stack(struct process *dest, const struct process *src)&#10;{&#10;    dest-&gt;user_stack = kzalloc(USER_STACK_SIZE);&#10;    memcpy(dest-&gt;user_stack, src-&gt;user_stack, USER_STACK_SIZE);&#10;    memcpy(dest-&gt;thread-&gt;kernel_stack, src-&gt;thread-&gt;kernel_stack, KERNEL_STACK_SIZE);&#10;}&#10;&#10;void process_copy_file_info(struct process *dest, const struct process *src)&#10;{&#10;    memcpy(dest-&gt;file_name, src-&gt;file_name, sizeof(src-&gt;file_name));&#10;    dest-&gt;file_type = src-&gt;file_type;&#10;    if (dest-&gt;file_type == PROCESS_FILE_TYPE_ELF) {&#10;        dest-&gt;elf_file             = kzalloc(sizeof(struct elf_file));&#10;        dest-&gt;elf_file-&gt;elf_memory = kzalloc(src-&gt;elf_file-&gt;in_memory_size);&#10;        memcpy(dest-&gt;elf_file-&gt;elf_memory, src-&gt;elf_file-&gt;elf_memory, src-&gt;elf_file-&gt;in_memory_size);&#10;        dest-&gt;elf_file-&gt;in_memory_size = src-&gt;elf_file-&gt;in_memory_size;&#10;        strncpy(dest-&gt;elf_file-&gt;filename, src-&gt;elf_file-&gt;filename, sizeof(src-&gt;elf_file-&gt;filename));&#10;        dest-&gt;elf_file-&gt;virtual_base_address = src-&gt;elf_file-&gt;virtual_base_address;&#10;        dest-&gt;elf_file-&gt;virtual_end_address  = src-&gt;elf_file-&gt;virtual_end_address;&#10;&#10;        const int res = elf_process_loaded(dest-&gt;elf_file);&#10;        if (res &lt; 0) {&#10;            panic(&quot;Failed to process loaded ELF file&quot;);&#10;        }&#10;&#10;    } else {&#10;        dest-&gt;pointer = kzalloc(src-&gt;size);&#10;        memcpy(dest-&gt;pointer, src-&gt;pointer, src-&gt;size);&#10;    }&#10;    dest-&gt;size = src-&gt;size;&#10;}&#10;&#10;void process_copy_arguments(struct process *dest, const struct process *src)&#10;{&#10;    dest-&gt;current_directory = process_malloc(dest, MAX_PATH_LENGTH);&#10;    memcpy(dest-&gt;current_directory, src-&gt;current_directory, MAX_PATH_LENGTH);&#10;&#10;    dest-&gt;arguments.argv = process_malloc(dest, sizeof(char *) * src-&gt;arguments.argc);&#10;    for (int i = 0; i &lt; src-&gt;arguments.argc; i++) {&#10;        dest-&gt;arguments.argv[i] = process_malloc(dest, strlen(src-&gt;arguments.argv[i]) + 1);&#10;        strncpy(dest-&gt;arguments.argv[i], src-&gt;arguments.argv[i], strlen(src-&gt;arguments.argv[i]) + 1);&#10;    }&#10;}&#10;&#10;void process_copy_thread(struct process *dest, const struct process *src)&#10;{&#10;    struct thread *thread = thread_create(dest);&#10;    if (ISERR(thread)) {&#10;        panic(&quot;Failed to create thread&quot;);&#10;    }&#10;&#10;    dest-&gt;thread            = thread;&#10;    dest-&gt;thread-&gt;process   = dest;&#10;    dest-&gt;thread-&gt;time_used = 0;&#10;&#10;    dest-&gt;thread-&gt;context-&gt;ebp = src-&gt;thread-&gt;context-&gt;ebp;&#10;    dest-&gt;thread-&gt;context-&gt;ebx = src-&gt;thread-&gt;context-&gt;ebx;&#10;    dest-&gt;thread-&gt;context-&gt;esi = src-&gt;thread-&gt;context-&gt;esi;&#10;    dest-&gt;thread-&gt;context-&gt;edi = src-&gt;thread-&gt;context-&gt;edi;&#10;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;cs     = src-&gt;thread-&gt;trap_frame-&gt;cs;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;ds     = src-&gt;thread-&gt;trap_frame-&gt;ds;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;es     = src-&gt;thread-&gt;trap_frame-&gt;es;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;fs     = src-&gt;thread-&gt;trap_frame-&gt;fs;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;gs     = src-&gt;thread-&gt;trap_frame-&gt;gs;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;ss     = src-&gt;thread-&gt;trap_frame-&gt;ss;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;eflags = src-&gt;thread-&gt;trap_frame-&gt;eflags;&#10;    // dest-&gt;thread-&gt;trap_frame-&gt;eip              = src-&gt;thread-&gt;trap_frame-&gt;eip;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;esp              = src-&gt;thread-&gt;trap_frame-&gt;esp;&#10;    dest-&gt;thread-&gt;trap_frame-&gt;interrupt_number = src-&gt;thread-&gt;trap_frame-&gt;interrupt_number;&#10;}&#10;&#10;void process_copy_file_descriptors(struct process *dest, struct process *src)&#10;{&#10;    for (int i = 0; i &lt; MAX_FILE_DESCRIPTORS; i++) {&#10;        if (src-&gt;file_descriptors[i]) {&#10;            struct file *desc = kzalloc(sizeof(struct file));&#10;            if (!desc) {&#10;                panic(&quot;Failed to allocate memory for file descriptor&quot;);&#10;            }&#10;&#10;            memcpy(desc, src-&gt;file_descriptors[i], sizeof(struct file));&#10;            dest-&gt;file_descriptors[i] = desc;&#10;        }&#10;    }&#10;}&#10;&#10;struct process *process_clone(struct process *process)&#10;{&#10;    struct process *clone = kzalloc(sizeof(struct process));&#10;&#10;    if (!clone) {&#10;        panic(&quot;Failed to allocate memory for process clone&quot;);&#10;        return nullptr;&#10;    }&#10;&#10;    const int pid = process_get_free_pid();&#10;    if (pid &lt; 0) {&#10;        kfree(clone);&#10;        panic(&quot;No free process slot&quot;);&#10;        return nullptr;&#10;    }&#10;&#10;    clone-&gt;pid    = pid;&#10;    clone-&gt;parent = process;&#10;&#10;    // This is not super efficient&#10;&#10;    process_copy_file_descriptors(clone, process);&#10;    process_copy_file_info(clone, process);&#10;    process_copy_thread(clone, process);&#10;    process_copy_stack(clone, process);&#10;    process_copy_arguments(clone, process);&#10;    process_map_memory(clone);&#10;    process_copy_allocations(clone, process);&#10;&#10;    acquire(&amp;process_list.lock);&#10;    process_set(clone-&gt;pid, clone);&#10;    release(&amp;process_list.lock);&#10;&#10;    clone-&gt;rand_id = (int)get_random();&#10;&#10;    return clone;&#10;}&#10;&#10;void process_command_argument_free(struct command_argument *argument)&#10;{&#10;    if (argument-&gt;next) {&#10;        process_command_argument_free(argument-&gt;next);&#10;    }&#10;    kfree(argument);&#10;}&#10;&#10;void process_free_file_descriptor(struct process *process, struct file *desc)&#10;{&#10;    process-&gt;file_descriptors[desc-&gt;index] = nullptr;&#10;    // Do not free device inodes&#10;    if (desc-&gt;inode &amp;&amp; desc-&gt;inode-&gt;type != INODE_DEVICE &amp;&amp; desc-&gt;fs_type != FS_TYPE_RAMFS) {&#10;        if (desc-&gt;inode-&gt;data) {&#10;            kfree(desc-&gt;inode-&gt;data);&#10;        }&#10;        kfree(desc-&gt;inode);&#10;    }&#10;    kfree(desc);&#10;}&#10;&#10;int process_new_file_descriptor(struct process *process, struct file **desc_out)&#10;{&#10;    int res = -ENOMEM;&#10;    for (int i = 0; i &lt; MAX_FILE_DESCRIPTORS; i++) {&#10;        if (process-&gt;file_descriptors[i] == nullptr) {&#10;            struct file *desc = kzalloc(sizeof(struct file));&#10;            if (desc == nullptr) {&#10;                panic(&quot;Failed to allocate memory for file descriptor\n&quot;);&#10;                res = -ENOMEM;&#10;                break;&#10;            }&#10;&#10;            desc-&gt;index                  = i;&#10;            process-&gt;file_descriptors[i] = desc;&#10;            *desc_out                    = desc;&#10;            res                          = 0;&#10;            break;&#10;        }&#10;    }&#10;&#10;    return res;&#10;}&#10;&#10;struct file *process_get_file_descriptor(const struct process *process, const uint32_t index)&#10;{&#10;    if (index &gt; MAX_FILE_DESCRIPTORS - 1) {&#10;        return nullptr;&#10;    }&#10;&#10;    return process-&gt;file_descriptors[index];&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>