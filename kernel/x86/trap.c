#include "assert.h"
#include "types.h"
#include "defs.h"
#include "mmu.h"
#include "printf.h"
#include "proc.h"
#include "scheduler.h"
#include "x86.h"
#include "traps.h"
#include "spinlock.h"
#include "termcolors.h"
#include "string.h"

/** @brief Interrupt descriptor table shared by all CPUs. */
struct gate_desc idt[256];
/** @brief Trap handler entry points generated by vectors.S. */
extern u32 vectors[]; // in vectors.asm: array of 256 entry pointers
/** @brief Spinlock protecting ticks. */
struct spinlock tickslock;
/** @brief Global tick counter incremented by the timer interrupt. */
volatile u32 ticks;

extern struct process_queue runnable_queue;

char *exception_messages[] = {
    "Division By Zero",
    "Debug",
    "Non Maskable Interrupt",
    "Breakpoint",
    "Into Detected Overflow",
    "Out of Bounds",
    "Invalid Opcode",
    "No Coprocessor",
    "Double Fault",
    "Coprocessor Segment Overrun",
    "Bad TSS",
    "Segment Not Present",
    "Stack Fault",
    "General Protection Fault",
    "Page Fault",
    "Unknown Interrupt",
    "x87 FPU Floating-Point Error",
    "Alignment Check",
    "Machine Check",
    "SIMD Floating-Point Exception",
    "Virtualization Exception",
    "Control Protection Exception",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Security Exception",
    "Reserved"
};

static INTERRUPT_CALLBACK_FUNCTION interrupt_callbacks[TOTAL_INTERRUPTS];

void idt_register_interrupt_callback(int interrupt, INTERRUPT_CALLBACK_FUNCTION interrupt_callback)
{
    ASSERT(interrupt >= 0 && interrupt < TOTAL_INTERRUPTS, "idt_register_interrupt_callback: interrupt out of bounds");

    interrupt_callbacks[interrupt] = interrupt_callback;
}

void syscall_handler(struct trapframe *tf)
{
    if (current_process()->killed) {
        exit();
    }
    current_process()->trap_frame = tf;
    syscall();
    if (current_process()->killed) {
        exit();
    }
}

void exception_handler(struct trapframe *tf)
{
    if ((tf->cs & DPL_USER) == DPL_USER) {
        printf("Process " KBWHT "%s" KWHT " (%d)" KYEL " USER MODE EXCEPTION:" KRESET " %s\n",
               current_process()->name,
               current_process()->pid,
               exception_messages[tf->trapno]);
        printf(KBWHT "EIP:" KRESET " 0x%x\n", tf->eip);
        printf(KBWHT "CS:" KRESET " 0x%x\n", tf->cs);
        printf(KBWHT "EFLAGS:" KRESET " 0x%x\n", tf->eflags);
        current_process()->killed = 1;
        return;
    }

    printf("CPU %d" KYEL " KERNEL MODE EXCEPTION:" KRESET " %s\n", cpu_index(), exception_messages[tf->trapno]);
    printf(KBWHT "EIP:" KRESET " 0x%x ", tf->eip);
    printf(KBWHT "CS:" KRESET " 0x%x ", tf->cs);
    printf(KBWHT "EFLAGS:" KRESET " 0x%x ", tf->eflags);
    if ((tf->cs == (SEG_UCODE << 3)) | DPL_USER) {
        printf(KBWHT "ESP:" KRESET " 0x%x ", tf->esp);
        printf(KBWHT "SS:" KRESET " 0x%x ", tf->ss);
    }
    printf("\n");
    panic("exception_handler");
}


void timer_handler([[maybe_unused]] struct trapframe *tf)
{
    if (cpu_index() == 0) {
        acquire(&tickslock);
        ticks++;
        wakeup((void *)&ticks);
        release(&tickslock);
    }
    lapic_ack_interrupt(); // Acknowledge the interrupt
}

void ide_handler([[maybe_unused]] struct trapframe *tf)
{
    ideintr();
    lapic_ack_interrupt(); // Acknowledge the interrupt
}

void keyboard_handler([[maybe_unused]] struct trapframe *tf)
{
    keyboard_interrupt_handler();
    lapic_ack_interrupt(); // Acknowledge the interrupt
}

void uart_handler([[maybe_unused]] struct trapframe *tf)
{
    uartintr();
    lapic_ack_interrupt(); // Acknowledge the interrupt
}

void spurious_handler(struct trapframe *tf)
{
    printf("cpu%d: spurious interrupt at %x:%x\n",
           cpu_index(),
           tf->cs,
           tf->eip);
    lapic_ack_interrupt();
}

void page_fault_handler(struct trapframe *tf)
{
    u32 faulting_address = rcr2();
    printf("Process:" KBWHT " %s" KRESET " (%d). Page fault at address 0x%x, eip 0x%x\n",
           current_process()->name,
           current_process()->pid,
           faulting_address,
           tf->eip);
    current_process()->killed = 1;
}

void device_not_available_handler([[maybe_unused]] struct trapframe *tf)
{
    // Handle FPU/XSAVE exceptions by restoring the FPU state for the current process.
    // This allows lazy FPU context switching. We only restore the FPU state when the process
    // actually tries to use the FPU. For this to work, we first need to enable the FPU by
    // setting the TS flag in CR0 before switching to a process in the scheduler.
    struct proc *p = current_process();
    if (p) {
        clts();
        fpu_restore_state(p);
    }
}

/**
 * @brief Initialize the IDT entries for traps and interrupts.
 */
void trap_vectors_init(void)
{
    for (int i = 0; i < 256; i++) {
        SETGATE(idt[i], 0, SEG_KCODE << 3, vectors[i], 0);
    }
    SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);


    for (int i = 0; i < 0x20; i++) {
        idt_register_interrupt_callback(i, exception_handler);
    }

    idt_register_interrupt_callback(T_NM, device_not_available_handler);
    idt_register_interrupt_callback(T_PGFLT, page_fault_handler);
    idt_register_interrupt_callback(T_SYSCALL, syscall_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_TIMER, timer_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_IDE, ide_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_KBD, keyboard_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_COM1, uart_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_SPURIOUS, spurious_handler);
    idt_register_interrupt_callback(T_IRQ0 + 7, spurious_handler);

    initlock(&tickslock, "time");
}

/** @brief Load the IDT register with the kernel's descriptor table. */
void idtinit(void)
{
    lidt(idt, sizeof(idt));
}

/**
 * @brief Central trap and interrupt dispatcher.
 *
 * @param tf Trap frame captured at the time of the trap/interrupt.
 */
void trap(struct trapframe *tf)
{
    if (interrupt_callbacks[tf->trapno]) {
        interrupt_callbacks[tf->trapno](tf);
    } else {
        if (current_process() == nullptr || (tf->cs & 3) == 0) {
            // In kernel, it must be our mistake.
            printf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
                   tf->trapno,
                   cpu_index(),
                   tf->eip,
                   rcr2());
            panic("trap");
        }
        // In user space, assume the process misbehaved.
        printf("pid %d %s: trap %d err %d on cpu %d "
               "eip 0x%x addr 0x%x--kill proc\n",
               current_process()->pid,
               current_process()->name,
               tf->trapno,
               tf->err,
               cpu_index(),
               tf->eip,
               rcr2());
        current_process()->killed = 1;
    }

    if (tf->trapno == T_IRQ0 + IRQ_TIMER) {
        struct cpu *cpu = current_cpu();
        if (cpu->proc != nullptr && cpu->time_slice_ticks > 0) {
            cpu->time_slice_ticks--;
        }
    }

    // Force process exit if it has been killed and is in user space.
    // (If it is still executing in the kernel, let it keep running
    // until it gets to the regular system call return.)
    if (current_process() && current_process()->killed && (tf->cs & 3) == DPL_USER) {
        exit();
    }

    // Force the process to give up CPU.
    // If interrupts were on while locks held, would need to check nlock.
    if (current_process() && current_process()->state == RUNNING &&
        tf->trapno == T_IRQ0 + IRQ_TIMER && runnable_queue.size > 1) {
        struct cpu *cpu = current_cpu();
        // Only preempt if the time slice has expired
        if (cpu->time_slice_ticks <= 0) {
            cpu->time_slice_ticks = TIME_SLICE_TICKS;
            yield();
        }
    }

    // Check if the process has been killed since we yielded
    if (current_process() && current_process()->killed && (tf->cs & 3) == DPL_USER) {
        exit();
    }
}