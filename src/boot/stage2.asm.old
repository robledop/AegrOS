; stage2.asm (Stage 2 Bootloader)
BITS 16
ORG 0x8000   ; Must match STAGE2_SEGMENT:STAGE2_OFFSET from Stage 1

start:
    cli
    ; Preserve BootDrive variable from Stage 1 if needed
    mov ax, ds
    mov ds, ax            ; Ensure DS is correct
    mov [BootDrive], dl   ; Store boot drive number

    ; Load the kernel using INT 13h Extended Read
    ; Set up Disk Address Packet (DAP) for the kernel
    lea si, [Kernel_DAP]

    ; DAP size (16 bytes)
    mov byte [si], 16               ; dap_size
    mov byte [si+1], 0              ; dap_reserved

    ; Number of sectors to read
    mov word [si+2], KERNEL_SECTORS ; dap_num_sectors

    ; Transfer buffer pointer (Segment:Offset)
    mov word [si+4], KERNEL_OFFSET  ; dap_buffer (Offset)
    mov word [si+6], KERNEL_SEGMENT ; dap_buffer (Segment)

    ; Starting LBA (split into words)
    mov ax, word [KERNEL_LBA]             ; Lower 16 bits
    mov word [si+8], ax

    mov ax, word [KERNEL_LBA + 2]         ; Upper 16 bits
    mov word [si+10], ax

    ; Upper 32 bits of LBA (assuming LBA fits in 32 bits)
    mov word [si+12], 0
    mov word [si+14], 0

    ; Read the kernel
    mov ah, 0x42
    mov dl, [BootDrive]              ; Use the same boot drive
    mov si, Kernel_DAP
    int 0x13
    jc disk_error

    ; Set up GDT and switch to protected mode
    cli
    lgdt [gdt_descriptor]
    mov eax, cr0
    or eax, 0x1                      ; Set PE bit
    mov cr0, eax
    ; Far jump to clear prefetch queue and load CS
    jmp CODE_SEG:protected_mode_entry

disk_error:
    ; Handle disk read error
    hlt

BootDrive db 0x00

Kernel_DAP:
    times 16 db 0                  ; Allocate 16 bytes for the DAP

; Constants
KERNEL_SEGMENT equ 0x1000          ; Segment where kernel is loaded
KERNEL_OFFSET  equ 0x0000          ; Offset where kernel is loaded
KERNEL_LBA     dd 6                ; Starting LBA of the kernel
KERNEL_SECTORS equ 100             ; Number of sectors to read

; GDT setup
gdt_start:
    ; Null descriptor
    dq 0x0000000000000000

    ; Code segment descriptor (offset 0x08)
    dw 0xFFFF                      ; Limit Low
    dw 0x0000                      ; Base Low
    db 0x00                        ; Base Middle
    db 10011010b                   ; Access Byte
    db 11001111b                   ; Flags and Limit High
    db 0x00                        ; Base High

    ; Data segment descriptor (offset 0x10)
    dw 0xFFFF                      ; Limit Low
    dw 0x0000                      ; Base Low
    db 0x00                        ; Base Middle
    db 10010010b                   ; Access Byte
    db 11001111b                   ; Flags and Limit High
    db 0x00                        ; Base High

gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

; Constants for segment selectors
CODE_SEG equ 0x08                  ; Offset of code segment in GDT
DATA_SEG equ 0x10                  ; Offset of data segment in GDT

; Protected mode entry point
[BITS 32]
protected_mode_entry:
    ; Update segment registers
    mov ax, DATA_SEG
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    ; Set up stack
    mov esp, 0x9FC00

    ; Jump to kernel entry point
    jmp CODE_SEG:KERNEL_LINEAR_ADDR

; Linear address of kernel entry point
KERNEL_LINEAR_ADDR equ (KERNEL_SEGMENT << 4) + KERNEL_OFFSET

times 510 - ($ - $$) db 0
dw 0xAA55                          ; Boot signature (optional for Stage 2)
