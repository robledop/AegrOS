#include <stdint.h>


#define KERNEL_LBA       1      // Starting LBA of the kernel (adjust as needed)
#define KERNEL_SECTORS   300    // Number of sectors to read
#define KERNEL_LOAD_ADDR 0x100000 // Address to load the kernel

void load_kernel() {
    uint8_t *kernel_buffer = (uint8_t *)KERNEL_LOAD_ADDR;
    ata_lba_read(KERNEL_LBA, KERNEL_SECTORS, kernel_buffer);

    // Jump to the kernel entry point (assuming it's at KERNEL_LOAD_ADDR)
    void (*kernel_entry)() = (void (*)())KERNEL_LOAD_ADDR;
    kernel_entry();
}

// Define port I/O functions (implement these as needed)
uint8_t inb(uint16_t port);
void outb(uint16_t port, uint8_t value);
uint16_t inw(uint16_t port);
void outw(uint16_t port, uint16_t value);

// Delay function (optional, may be needed for port I/O timing)
void io_wait()
{
    // Implement a small delay if necessary (e.g., read from an unused port)
    asm volatile("outb %%al, $0x80" : : "a"(0));
}

// ATA command and status ports
#define ATA_DATA 0x1F0
#define ATA_ERROR 0x1F1
#define ATA_SECTOR_CNT 0x1F2
#define ATA_LBA_LOW 0x1F3
#define ATA_LBA_MID 0x1F4
#define ATA_LBA_HIGH 0x1F5
#define ATA_DRIVE 0x1F6
#define ATA_COMMAND 0x1F7
#define ATA_STATUS 0x1F7

// ATA commands
#define ATA_CMD_READ_SECTORS 0x20

// ATA status bits
#define ATA_SR_BSY 0x80  // Busy
#define ATA_SR_DRDY 0x40 // Drive ready
#define ATA_SR_DRQ 0x08  // Data request ready

// Function prototypes
void ata_lba_read(uint32_t lba, uint16_t total_sectors, uint8_t *buffer);
void ata_read_sectors(uint32_t lba, uint8_t sector_count, uint8_t *buffer);

// Function implementations

// Reads sectors from disk using ATA PIO mode
// Inputs:
//   lba           - Starting LBA address
//   total_sectors - Total number of sectors to read
//   buffer        - Destination buffer to store the read data
void ata_lba_read(uint32_t lba, uint16_t total_sectors, uint8_t *buffer)
{
    while (total_sectors > 0)
    {
        uint8_t sectors_to_read = (total_sectors >= 256) ? 256 : total_sectors;
        ata_read_sectors(lba, sectors_to_read, buffer);

        lba += sectors_to_read;
        buffer += sectors_to_read * 512;
        total_sectors -= sectors_to_read;
    }
}

// Reads up to 256 sectors from disk using ATA PIO mode
// Inputs:
//   lba          - Starting LBA address
//   sector_count - Number of sectors to read (1 to 256)
//   buffer       - Destination buffer to store the read data
void ata_read_sectors(uint32_t lba, uint8_t sector_count, uint8_t *buffer)
{
    // Wait for the drive to be ready
    while (inb(ATA_STATUS) & ATA_SR_BSY)
        ;

    // Set drive to master and LBA mode, bits 24-27 of LBA in drive/head register
    outb(ATA_DRIVE, 0xE0 | ((lba >> 24) & 0x0F));

    // Set sector count
    outb(ATA_SECTOR_CNT, sector_count);

    // Set LBA low byte (bits 0-7)
    outb(ATA_LBA_LOW, lba & 0xFF);

    // Set LBA mid byte (bits 8-15)
    outb(ATA_LBA_MID, (lba >> 8) & 0xFF);

    // Set LBA high byte (bits 16-23)
    outb(ATA_LBA_HIGH, (lba >> 16) & 0xFF);

    // Send the READ SECTORS command
    outb(ATA_COMMAND, ATA_CMD_READ_SECTORS);

    for (uint16_t i = 0; i < sector_count; i++)
    {
        // Wait for the drive to signal that it's ready to transfer data
        while (!(inb(ATA_STATUS) & ATA_SR_DRQ))
            ;

        // Read a sector (256 words = 512 bytes)
        for (uint16_t j = 0; j < 256; j++)
        {
            uint16_t data = inw(ATA_DATA);
            buffer[0] = data & 0xFF;
            buffer[1] = (data >> 8) & 0xFF;
            buffer += 2;
        }

        // Wait for BSY and DRQ to clear before reading next sector
        while (inb(ATA_STATUS) & ATA_SR_BSY)
            ;
    }
}
