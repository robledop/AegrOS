  ; Boot loader
  ORG 0x7c00
  BITS 16

  CODE_SEG equ gdt_code - gdt_start
  DATA_SEG equ gdt_data - gdt_start

  ; BIOS Paramater Block
  ; https://wiki.osdev.org/FAT#Boot_Record
  jmp short start
  nop

 ; BIOS Parameter Block (BPB)
OEMID            db 'OSDEV   '   ; OEM Identifier
BytesPerSector   dw 0x200        ; 512 bytes per sector
SectorsPerCluster db 0x80       ; 1 sector per cluster (Adjusted for simplicity)
ReservedSectors  dw 1            ; 1 reserved sector (Adjusted for simplicity)
FATCopies        db 2            ; 2 FAT copies
RootDirEntries   dw 224          ; 224 root directory entries (Standard for FAT16)
NumSectors       dw 0            ; 0 sectors (uses SectorsBig)
MediaType        db 0xf8         ; Media type
SectorsPerFAT    dw 9            ; 9 sectors per FAT (Standard for FAT16)
SectorsPerTrack  dw 18           ; 18 sectors per track
NumberOfHeads    dw 2            ; 2 heads
HiddenSectors    dd 0            ; 0 hidden sectors
SectorsBig       dd 0x773594

; Extended BPB (DOS 4.0)
DriveNumber      db 0x00         ; Drive number
WinNTBit         db 0x00         ; Windows NT bit
Signature        db 0x29         ; Signature
VolumeID         dd 0x12345678   ; Volume ID
VolumeLabel      db 'NO NAME    '; Volume Label
SystemIDString   db 'FAT16   '   ; System ID String



start:
    cli
    mov ax, 0x07C0
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00
    sti

    ; Set up VGA text mode (optional)
    mov ax, 0x03
    int 0x10

    ; Jump to protected mode setup
    jmp 0x0:protected_mode_setup

; Protected mode setup
protected_mode_setup:
    cli
    lgdt [gdt_descriptor]
    mov eax, cr0
    or eax, 1
    mov cr0, eax
    jmp CODE_SEG:boot_pm

; Global Descriptor Table (GDT)
gdt_start:
gdt_null:
    dq 0x0

gdt_code:
    dw 0xFFFF
    dw 0x0
    db 0x0
    db 10011010b
    db 11001111b
    db 0x0

gdt_data:
    dw 0xFFFF
    dw 0x0
    db 0x0
    db 10010010b
    db 11001111b
    db 0x0

gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

[BITS 32]
boot_pm:
    ; Update segment registers
    mov ax, DATA_SEG
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, 0x90000

    ; Read root directory
    call read_root_directory

    ; Search for kernel.bin
    call find_kernel

    ; Read FAT
    call read_fat

    ; Load kernel
    call load_kernel

    ; Jump to kernel entry point
    jmp CODE_SEG:0x100000

; Read Root Directory
read_root_directory:
    ; Calculate root directory sector
    mov eax, [ReservedSectors]
    add eax, [FATCopies]
    mul word [SectorsPerFAT]
    mov ebx, eax          ; Root directory starts after reserved and FAT sectors

    ; Root directory size in sectors
    mov ecx, [RootDirEntries]
    imul ecx, 32
    mov edx, [BytesPerSector]
    div edx
    ; ECX now contains the number of sectors in the root directory

    ; Read root directory into memory at 0x8000
    mov edi, 0x8000
    call ata_lba_read
    ret

; Find kernel.bin in root directory
find_kernel:
    mov esi, 0x8000       ; Root directory start
    mov ecx, [RootDirEntries]
find_kernel_loop:
    mov eax, [esi]        ; Read first 4 bytes of entry
    cmp eax, 0            ; Check if entry is empty
    je not_found
    mov edi, kernel_name
    push esi
    push edi
    mov ecx, 11
    repe cmpsb
    pop edi
    pop esi
    je kernel_found
    add esi, 32           ; Next directory entry
    loop find_kernel_loop
not_found:
    ; Handle file not found (halt or display error)

    hlt

kernel_found:
    ; Read starting cluster and file size
    mov bx, [esi + 26]    ; Starting cluster
    mov dx, [esi + 28]    ; File size low word
    mov cx, [esi + 30]    ; File size high word
    shl ecx, 16
    or edx, ecx           ; EDX now contains file size
    ret

; Read FAT into memory
read_fat:
    mov eax, [ReservedSectors]  ; FAT starts after reserved sectors
    mov ecx, [SectorsPerFAT]    ; Number of sectors per FAT
    mov edi, 0xA000             ; Load FAT into memory at 0xA000
    call ata_lba_read
    ret

; Load kernel into memory
load_kernel:
    mov esi, ebx                ; Starting cluster
    mov edi, 0x100000           ; Kernel load address
    mov ebp, edx                ; File size
load_kernel_loop:
    ; Calculate LBA of the cluster
    mov eax, esi
    sub eax, 2
    mul dword [SectorsPerCluster]
    add eax, FirstDataSector
    ; Read cluster into memory
    mov ecx, [SectorsPerCluster]
    call ata_lba_read
    ; Update file size and pointers
    add edi, [BytesPerSector]
    sub ebp, [BytesPerSector]
    jle load_done
    ; Get next cluster from FAT
    mov ebx, esi
    shl ebx, 1                 ; FAT16 entry size is 2 bytes
    movzx esi, word [0xA000 + ebx]
    cmp esi, 0xFFF8            ; Check for end of cluster chain
    jb load_kernel_loop
load_done:
    ret

; ATA LBA Read Function
; Input:
;   EAX - LBA address
;   ECX - Sector count
;   EDI - Destination address
ata_lba_read:
  mov ebx, eax ; Backup the LBA
  ; Send the highest 8 bits of the LBA to hard disk controller
  shr eax, 24
  or eax, 0xE0  ; Select the master drive
  mov dx, 0x1F6
  out dx, al

  ; Send the total sectors to read
  mov eax, ecx
  mov dx, 0x1F2
  out dx, al

  ; Send more bits of the LBA
  mov eax, ebx ; Restore the backup LBA
  mov dx, 0x1F3
  out dx, al

  ; Send more bits of the LBA
  mov dx, 0x1F4
  mov eax, ebx ; Restore the backup LBA
  shr eax, 8
  out dx, al

  ; Send uppper 16 bits of the LBA
  mov dx, 0x1F5
  mov eax, ebx ; Restore the backup LBA
  shr eax, 16
  out dx, al

  mov dx, 0x1F7
  mov al, 0x20
  out dx, al

  ; Read all sectors into memory
.next_sector:
  push ecx

  ; Checking if we need to read
.try_again:
  mov dx, 0x1F7
  in al, dx
  test al, 8
  jz .try_again

  ; We need to read 256 words at a time
  mov ecx, 256
  mov dx, 0x1F0
  rep insw
  pop ecx
  loop .next_sector

  ret ; ata_lba_read

; Data Definitions
kernel_name db 'KERNEL  BIN'   ; 11-byte filename in 8.3 format
kernel_not_found db 'KERNEL.BIN not found', 0

; Constants for BPB values (Define as constants)
BPB_BytesPerSector     equ 512
BPB_SectorsPerCluster  equ 1
BPB_ReservedSectors    equ 1
BPB_FATCopies          equ 2
BPB_RootDirEntries     equ 224
BPB_SectorsPerFAT      equ 9

; Calculate First Data Sector
FirstDataSector equ (BPB_ReservedSectors + (BPB_FATCopies * BPB_SectorsPerFAT) + ((BPB_RootDirEntries * 32 + (BPB_BytesPerSector - 1)) / BPB_BytesPerSector))

; Bootloader signature
times 510 - ($ - $$) db 0
dw 0xAA55